<!DOCTYPE html>
<html>

<head>
  <link rel="icon" href="data:image/svg+xml,
    <svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 64 64%22>
      <text x=%2232%22 y=%2246%22 font-size=%2248%22 text-anchor=%22middle%22>‚ò†Ô∏è</text></svg>">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta charset="UTF-8">
  <title>Maze Game</title>
  <style>
    html,
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
    }

    canvas {
      display: block;
      margin: auto;
      background: #111;
    }

    body {
      font-family: sans-serif;
      color: #fff;
      text-align: center;
      font-size: 20px;
    }
  </style>
</head>

<body>
  <canvas id="game"></canvas>
  <script>
    let canvas = document.getElementById('game');
    let ctx = canvas.getContext('2d');
    let MAZE_WIDTH, MAZE_HEIGHT, cellSize;
    let maze = [], visitedPath = [], player = {}, exit = {};
    let direction = null, gameOver = false, win = false, lose = false;
    let waveCounter = 0, solutionPath = [], autoMoving = false, cheatMode = false;
    let playerColor = '#fff', exitColor = '#0f0', wallColor = '#222', pathColor = '#444', cheatPathColor = '#00f';
    let playerSize = 0.8; // New variable for player size 
    let wallThickness = 2; // New variable for wall thickness
    let pathThickness = 2; // New variable for path thickness
    let pathsize = 14; // New variable for path size
    var ended = false; // New variable for ended state
    let wincolor = '#fff530', wincolorgradient = '#0000ff'; // Win color
    let losecolor = '#960000', losecolorgradient = '#000000'; // Lose color
    let clock = 'üïõ'; // Clock emoji
    let startTime = Date.now();
    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      cellSize = 30;
      MAZE_WIDTH = Math.floor(canvas.width / cellSize);
      MAZE_HEIGHT = Math.floor(canvas.height / cellSize);
      generateMaze();
    }
    window.onresize = resize;

    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        let j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    function generateMaze() {
      maze = Array.from({ length: MAZE_HEIGHT }, () => Array(MAZE_WIDTH).fill(1));
      visitedPath = Array.from({ length: MAZE_HEIGHT }, () => Array(MAZE_WIDTH).fill(false));
      function carve(x, y) {
        maze[y][x] = 0;
        for (const [dx, dy] of shuffle([[1, 0], [-1, 0], [0, 1], [0, -1]])) {
          const nx = x + dx * 2;
          const ny = y + dy * 2;
          if (ny >= 0 && ny < MAZE_HEIGHT && nx >= 0 && nx < MAZE_WIDTH && maze[ny][nx] === 1) {
            maze[y + dy][x + dx] = 0;
            carve(nx, ny);
          }
        }
      }

      carve(Math.floor(MAZE_WIDTH / 2), Math.floor(MAZE_HEIGHT / 2));
      [player, exit] = randomFarPositions();
      visitedPath[player.y][player.x] = true;
      direction = null;
      gameOver = false;
      win = false;
      lose = false;
      solutionPath = [];
      autoMoving = false;
    }

    function randomFarPositions() {
      let candidates = [];
      for (let y = 0; y < MAZE_HEIGHT; y++) {
        for (let x = 0; x < MAZE_WIDTH; x++) {
          if (maze[y][x] === 0) candidates.push({ x, y });
        }
      }
      let start = candidates[Math.floor(Math.random() * candidates.length)];
      let end;
      let maxTry = 500;
      do {
        end = candidates[Math.floor(Math.random() * candidates.length)];
        const distance = Math.abs(start.x - end.x) + Math.abs(start.y - end.y);
        maxTry--;
        if (distance > (MAZE_WIDTH + MAZE_HEIGHT) / 1.5) break;
      } while (maxTry > 0);
      return [start, end];
    }

    function countAvailableDirs(x, y) {
      let count = 0;
      for (const [dx, dy] of [[1, 0], [-1, 0], [0, 1], [0, -1]]) {
        let nx = x + dx, ny = y + dy;
        if (nx >= 0 && ny >= 0 && nx < MAZE_WIDTH && ny < MAZE_HEIGHT && maze[ny][nx] === 0 && !visitedPath[ny][nx]) {
          count++;
        }
      }
      return count;
    }

    function moveAuto() {
      if (!direction || gameOver || !autoMoving) return;
      const [dx, dy] = direction;
      let nx = player.x + dx;
      let ny = player.y + dy;
      if (nx >= 0 && ny >= 0 && nx < MAZE_WIDTH && ny < MAZE_HEIGHT && maze[ny][nx] === 0 && !visitedPath[ny][nx]) {
        player.x = nx;
        player.y = ny;
        visitedPath[ny][nx] = true;
        if (player.x === exit.x && player.y === exit.y) {
          win = true;
          gameOver = true;
        }
        if (countAvailableDirs(player.x, player.y) !== 1) {
          direction = null;
          autoMoving = false;
          checkLose();
        }
      } else {
        direction = null;
        autoMoving = false;
        checkLose();
      }
    }

    function checkLose() {
      let hasMove = false;
      for (const [dx, dy] of [[1, 0], [-1, 0], [0, 1], [0, -1]]) {
        let nx = player.x + dx, ny = player.y + dy;
        if (nx >= 0 && ny >= 0 && nx < MAZE_WIDTH && ny < MAZE_HEIGHT && maze[ny][nx] === 0 && !visitedPath[ny][nx]) {
          hasMove = true;
        }
      }
      if (!hasMove && !win) {
        gameOver = true;
        lose = true;
        waveCounter--
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      for (let y = 0; y < MAZE_HEIGHT; y++) {
        for (let x = 0; x < MAZE_WIDTH; x++) {
          if (maze[y][x] === 1) {
            // Draw walls with thickness
            ctx.fillStyle = wallColor;
            ctx.fillRect(x * cellSize + wallThickness, y * cellSize + wallThickness, cellSize - wallThickness, cellSize - wallThickness);
          } else if (visitedPath[y][x]) {
            //make transparent 50% path
            ctx.fillStyle = pathColor;
            ctx.font = `${pathsize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            ctx.fillText('üë£', x * cellSize + cellSize / 2, y * cellSize + cellSize / 2);
          }
        }
      }

      for (let p of solutionPath) {
        ctx.fillStyle = cheatMode ? cheatPathColor : pathColor;
        ctx.beginPath();  // Draw small dots on the solution path smaller
        ctx.arc(p.x * cellSize + cellSize / 2, p.y * cellSize + cellSize / 2, pathThickness, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.fillStyle = exitColor; // Exit color
      //exit pixel castle emoji üè∞
      ctx.font = `${cellSize}px Arial`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('üè∞', exit.x * cellSize + cellSize / 2, exit.y * cellSize + cellSize / 2); // Draw exit as castle emoj
      //player pixel skull emoji üíÄ
      ctx.fillStyle = playerColor; // Player color
      ctx.font = `${cellSize}px Arial`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('üíÄ', player.x * cellSize + cellSize / 2, player.y * cellSize + cellSize / 2); // Draw player as skull emoj
      if (win || lose) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)'; // Semi-transparent overlay
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)'; // Semi-transparent overlay
        if (win) {
          let gradient = ctx.createLinearGradient(0, canvas.height, 0, 0);
          gradient.addColorStop(0, wincolor);
          gradient.addColorStop(1, wincolorgradient);
          ctx.fillStyle = gradient;


        } else {
          let gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
          gradient.addColorStop(0, losecolor);
          gradient.addColorStop(1, losecolorgradient);
          ctx.fillStyle = gradient;
        }
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#fff';
        ctx.font = '48px sans-serif';
        ctx.textAlign = 'center';
        //3D EFECT MAZE ON SCREEN like in windows 98 pipes screen saver
        ctx.textBaseline = 'middle';
        ctx.shadowColor = 'rgba(0, 0, 0, 0.5)'; // Shadow color
        ctx.shadowOffsetX = 20; // Shadow offset X
        ctx.shadowOffsetY = 10; // Shadow offset Y
        ctx.shadowBlur = 20; // Shadow blur
        ctx.fillStyle = win ? wincolor : losecolor; // Text color
        ctx.font = 'bold 48px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        ctx.textShadow = '0 0 10px #000, 0 0 20px #000, 0 0 30px #000, 0 0 40px #000, 0 0 50px #000, 0 0 60px #000, 0 0 70px #000';
        if (cheatMode) {
          ctx.fillText('Cheater!!!!', canvas.width / 2, canvas.height / 2 - 20);
        } else {
          ctx.fillText(win ? 'You Win!' : 'Game Over', canvas.width / 2, canvas.height / 2 - 20);
        }
        ctx.fillText('Press Enter or SPACE ', canvas.width / 2, canvas.height / 2 + 20);
        ctx.fillText('Press H key for help', canvas.width / 2, canvas.height / 2 + 60);
      }
    }

    function gameLoop() {
      moveAuto();
      draw();
      requestAnimationFrame(gameLoop);
    }

    document.addEventListener('keydown', e => {
      if (gameOver && (e.key === 'Enter' || e.key === ' ')) {
        if (win && !cheatMode) {
          waveCounter++;
        }
        generateMaze();
        cheatMode = false;
        return;
      }
      if (['ArrowUp', 'w', 'W', '8'].includes(e.key)) startMove([0, -1]);
      if (['ArrowDown', 's', 'S', '2'].includes(e.key)) startMove([0, 1]);
      if (['ArrowLeft', 'a', 'A', '4'].includes(e.key)) startMove([-1, 0]);
      if (['ArrowRight', 'd', 'D', '6'].includes(e.key)) startMove([1, 0]);
      if (e.key === 'Escape') gameOver = true;
      if (e.key === 'h') {
        showhelp();
      }
      if (e.ctrlKey) {
        var c = e.which || e.keyCode;
        if (c == 82) {
          e.preventDefault();
          e.stopPropagation();
        }
      }
      if (e.key === 'Enter' && gameOver || e.key === 'r' && Date.now() - startTime < 10000 || e.key === 'R' && gameOver) {
        generateMaze();
      }
      if (e.key === 'c') {
        cheatMode = !cheatMode;  // Toggle cheat mode
        if (cheatMode) {
          revealSolutionPath();  // Reveal solution path if cheat mode is enabled
        }
      }
      // key presed if cheatmode enabled pres v to auto win move to win animated 
      if (cheatMode && e.key === 'v') {
        //prevention multiple calls
        if (autoMoving) return; // Prevent multiple calls to auto-move
        // Start auto-move to win position  
        autoMoving = true;
        direction = null; // Stop auto-move in the current direction
        let pathIndex = 0; // Index to track the current position in the solution path
        function moveToWin() {//make smooth animation to win position
          if (pathIndex < solutionPath.length) {
            player.x = solutionPath[pathIndex].x;
            player.y = solutionPath[pathIndex].y;
            pathIndex++;
            requestAnimationFrame(moveToWin);
          } else {
            win = true;
            gameOver = true;
          }
        }
        moveToWin(); // Start moving to the win position
      }
    });
    function revealSolutionPath() {
      let queue = [{ x: player.x, y: player.y, path: [] }];
      let visited = Array.from({ length: MAZE_HEIGHT }, () => Array(MAZE_WIDTH).fill(false));
      visited[player.y][player.x] = true;

      while (queue.length > 0) {
        let { x, y, path } = queue.shift();
        if (x === exit.x && y === exit.y) {
          solutionPath = [...path, { x, y }];
          return;
        }
        for (let [dx, dy] of [[1, 0], [-1, 0], [0, 1], [0, -1]]) {
          let nx = x + dx, ny = y + dy;
          if (nx >= 0 && ny >= 0 && nx < MAZE_WIDTH && ny < MAZE_HEIGHT) {
            if (!visited[ny][nx] && maze[ny][nx] === 0) {
              visited[ny][nx] = true;
              queue.push({ x: nx, y: ny, path: [...path, { x, y }] });
            }
          }
        }
      }
    }

    let touchStartX = 0;
    let touchStartY = 0;

    canvas.addEventListener("touchstart", e => {
      if (!gameOver) {
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
        return;
      }
    });

    canvas.addEventListener("touchend", e => {
      if (gameOver) {
        generateMaze();
        return;
      } else {

        let dx = e.changedTouches[0].clientX - touchStartX;
        console.log(dx);
        let dy = e.changedTouches[0].clientY - touchStartY;
        console.log(dy);
        if (Math.abs(dx) < Math.abs(dy)) {
          if (dy > 0) startMove([0, 1]);
          else startMove([0, -1]);
        } else if (dx > 0) {
          startMove([1, 0]);
        } else {
          startMove([-1, 0]);
        }
      }
    });
    function startMove(dir) {
      direction = dir;
      autoMoving = true;
    }

    canvas.onclick = function (e) {
      let rect = canvas.getBoundingClientRect();
      let mx = Math.floor((e.clientX - rect.left) / cellSize);
      let my = Math.floor((e.clientY - rect.top) / cellSize);
      if (mx === exit.x && my === exit.y) {
        revealSolutionPath();
      }
    };

    function revealSolutionPath() {
      let queue = [{ x: player.x, y: player.y, path: [] }];
      let visited = Array.from({ length: MAZE_HEIGHT }, () => Array(MAZE_WIDTH).fill(false));
      visited[player.y][player.x] = true;

      while (queue.length > 0) {
        let { x, y, path } = queue.shift();
        if (x === exit.x && y === exit.y) {
          solutionPath = [...path, { x, y }];
          return;
        }
        for (let [dx, dy] of [[1, 0], [-1, 0], [0, 1], [0, -1]]) {
          let nx = x + dx, ny = y + dy;
          if (nx >= 0 && ny >= 0 && nx < MAZE_WIDTH && ny < MAZE_HEIGHT) {
            if (!visited[ny][nx] && maze[ny][nx] === 0) {
              visited[ny][nx] = true;
              queue.push({ x: nx, y: ny, path: [...path, { x, y }] });
            }
          }
        }
      }
    }
    function updateTimer() {
      if (gameOver && !ended || gameOver && win) {
        startTime = Date.now();
        return;
      }
      if (!gameOver) {
        let elapsedTime = Math.floor((Date.now() - startTime) / 1000);
        if (elapsedTime.toString().split('').pop() === "0") {
          clock = 'üïõ';
        } else if (elapsedTime.toString().split('').pop() === "2") {
          clock = 'üïí';
        } else if (elapsedTime.toString().split('').pop() === "5") {
          clock = 'üïï';
        } else if (elapsedTime.toString().split('').pop() === "8") {
          clock = 'üïò';
        }
        if (Date.now() - startTime > 5000) {
          ctx.fillStyle = '#fff'; // Text color
          ctx.font = '14px sans-serif'; //disable scaling
          ctx.textBaseline = 'top'; // Align text to the top
          ctx.textAlign = 'left';
          ctx.fillText(`${clock}${elapsedTime}`, 2, 7); // Display elapsed time
        }
        if (waveCounter !== 0) {
          ctx.fillStyle = '#fff'; // Text color
          ctx.font = '14px sans-serif'; //disable scaling
          ctx.textBaseline = 'top'; // Align text to the top
          ctx.textAlign = 'right';
          ctx.fillText(`${waveCounter}üëë`, canvas.width - 2, 7); // Display elapsed time
        }
      }
    }
    function showhelp() {
      alert("Controls:\
      \nArrow keys ‚¨ÜÔ∏è‚¨ÖÔ∏è‚¨áÔ∏è‚û°Ô∏èor WASD to move\
      \nEnter or Space to restart\
      \nR in first 5 secs to restart\
      \nClick on the exit to reveal the solution path\
      \nTouch the screen to move\
      \nC to toggle cheat mode\
      \nV to auto win in cheat mode\
      \nH for help");

    }

    function gameLoop() {
      moveAuto();
      draw();
      updateTimer(); // Update timer on each frame
      requestAnimationFrame(gameLoop);
    }
    resize();
    gameLoop();
  </script>
</body>

</html>