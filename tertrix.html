<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Tetris Touch</title>
  <style>
    html, body { margin: 0; padding: 0; background: #000; overflow: hidden; }
    canvas { display: block; margin: auto; background: #111; touch-action: none; }
  </style>
</head>
<body>
<canvas id="game"></canvas>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

const COLS = 10, ROWS = 20, NEXT_SIZE = 6;
let BLOCK = 30;
let grid, current, next, dropTime, gameOver;
let touchStartX = 0, touchStartY = 0;

const colors = [
  '#000', '#0ff', '#00f', '#f0f', '#0f0', '#f00', '#ff0', '#fa0'
];

const shapes = [
  [[1,1,1,1]],                         // I
  [[1,1,0],[0,1,1]],                   // Z
  [[0,1,1],[1,1,0]],                   // S
  [[1,1],[1,1]],                       // O
  [[1,0,0],[1,1,1]],                   // J
  [[0,0,1],[1,1,1]],                   // L
  [[0,1,0],[1,1,1]]                    // T
];

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  BLOCK = Math.min(canvas.height / ROWS, canvas.width / (COLS + NEXT_SIZE + 2));
}
window.onresize = resize;

function reset() {
  grid = Array.from({length: ROWS}, () => Array(COLS).fill(0));
  current = randomPiece();
  next = randomPiece();
  dropTime = Date.now();
  gameOver = false;
}

function randomPiece() {
  let id = Math.floor(Math.random() * shapes.length) + 1;
  let shape = shapes[id-1];
  return {shape, x: Math.floor(COLS/2) - Math.ceil(shape[0].length/2), y: -1, id};
}

function collide(p) {
  for (let y = 0; y < p.shape.length; y++) {
    for (let x = 0; x < p.shape[y].length; x++) {
      if (p.shape[y][x]) {
        let newX = p.x + x;
        let newY = p.y + y;
        if (newX < 0 || newX >= COLS || newY >= ROWS) return true;
        if (newY >= 0 && grid[newY][newX]) return true;
      }
    }
  }
  return false;
}

function merge(p) {
  for (let y = 0; y < p.shape.length; y++) {
    for (let x = 0; x < p.shape[y].length; x++) {
      if (p.shape[y][x]) {
        let newX = p.x + x;
        let newY = p.y + y;
        if (newY >= 0) grid[newY][newX] = p.id;
      }
    }
  }
}

function rotate(p) {
  let newShape = p.shape[0].map((_, i) => p.shape.map(row => row[i]).reverse());
  return {shape: newShape, x: p.x, y: p.y, id: p.id};
}

function move(dx) {
  let temp = {...current, x: current.x + dx};
  if (!collide(temp)) current = temp;
}

function drop() {
  if (gameOver) return;
  let temp = {...current, y: current.y + 1};
  if (!collide(temp)) {
    current = temp;
  } else {
    merge(current);
    clearLines();
    current = next;
    next = randomPiece();
    if (collide(current)) {
      gameOver = true;
    }
  }
  dropTime = Date.now();
}

function hardDrop() {
  while (!collide({...current, y: current.y+1})) {
    current.y++;
  }
  drop();
}

function clearLines() {
  let newGrid = grid.filter(row => row.some(cell => !cell));
  while (newGrid.length < ROWS) newGrid.unshift(Array(COLS).fill(0));
  grid = newGrid;
}

function ghostPiece() {
  let ghost = {...current};
  while (!collide({...ghost, y: ghost.y + 1})) ghost.y++;
  return ghost;
}

function drawSquare(x, y, id, alpha=1) {
  ctx.globalAlpha = alpha;
  ctx.fillStyle = colors[id];
  ctx.fillRect(x * BLOCK, y * BLOCK, BLOCK - 1, BLOCK - 1);
  ctx.globalAlpha = 1;
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  for (let y = 0; y < ROWS; y++)
    for (let x = 0; x < COLS; x++)
      if (grid[y][x]) drawSquare(x, y, grid[y][x]);

  let ghost = ghostPiece();
  for (let y = 0; y < ghost.shape.length; y++)
    for (let x = 0; x < ghost.shape[y].length; x++)
      if (ghost.shape[y][x])
        drawSquare(ghost.x + x, ghost.y + y, ghost.id, 0.3);

  for (let y = 0; y < current.shape.length; y++)
    for (let x = 0; x < current.shape[y].length; x++)
      if (current.shape[y][x])
        drawSquare(current.x + x, current.y + y, current.id);

  for (let y = 0; y < next.shape.length; y++)
    for (let x = 0; x < next.shape[y].length; x++)
      if (next.shape[y][x])
        drawSquare(COLS + 2 + x, 2 + y, next.id);

  ctx.fillStyle = "#fff";
  ctx.font = (BLOCK * 0.7) + "px Arial";
  ctx.fillText("NEXT:", (COLS + 2) * BLOCK, BLOCK * 1.5);

  if (gameOver) {
    ctx.fillStyle = "rgba(0,0,0,0.7)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "#fff";
    ctx.font = "48px Arial";
    ctx.textAlign = "center";
    ctx.fillText("GAME OVER", canvas.width/2, canvas.height/2);
    ctx.font = "24px Arial";
    ctx.fillText("Tap or Press Enter to Restart", canvas.width/2, canvas.height/2 + 50);
  }
}

document.addEventListener('keydown', e => {
  if (gameOver && e.key === 'Enter') reset();
  if (gameOver) return;
  if (e.key === 'ArrowLeft') move(-1);
  else if (e.key === 'ArrowRight') move(1);
  else if (e.key === 'ArrowDown') drop();
  else if (e.key === 'ArrowUp') {
    let rotated = rotate(current);
    if (!collide(rotated)) current = rotated;
  }
  else if (e.key === ' ') hardDrop();
});

canvas.addEventListener('touchstart', e => {
  touchStartX = e.touches[0].clientX;
  touchStartY = e.touches[0].clientY;
});

canvas.addEventListener('touchend', e => {
  if (gameOver) {
    reset();
    return;
  }
  let dx = e.changedTouches[0].clientX - touchStartX;
  let dy = e.changedTouches[0].clientY - touchStartY;
  if (Math.abs(dx) > Math.abs(dy)) {
    if (dx > 30) move(1);
    else if (dx < -30) move(-1);
  } else {
    if (dy > 30) drop();
    else if (dy < -30) {
      let rotated = rotate(current);
      if (!collide(rotated)) current = rotated;
    }
  }
});

function update() {
  if (!gameOver && Date.now() - dropTime > 500) drop();
  draw();
  requestAnimationFrame(update);
}

resize();
reset();
update();
</script>
</body>
</html>
